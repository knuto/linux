#!/usr/bin/python

# SPDX-License-Identifier: GPL-2.0
#
# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
#    Author: Knut Omang <knut.omang@oracle.com>
#
# The program implements a generic and extensible code checker runner
# that supports running various checker tools from the kernel Makefile
# or standalone, with options for selectively suppressing individual
# checks on a per file or per check basis.
#
# The program has some generic support for checkers, but to implement
# support for a new checker to the full extent, it might be necessary to
#   1) subclass the Checker class in this file with checker specific processing.
#   2) add typedef definitions in runchecks.cfg in this directory
#
# This version of runchecks has full support for the following tools:
#   sparse:      installed separately
#   checkpatch:  checkpatch.pl
#   checkdoc:    kernel-doc -none
#   smatch:      built from http://repo.or.cz/w/smatch.git
#
# See file "Documentation/dev-tools/runchecks.rst" for more details
#

import sys
import os
import argparse
import subprocess
import fcntl
import select
import re

from os.path import dirname, basename


class CheckError(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value


def usage_add():
    print("")
    print("Configured checkers:")
    for (c, v) in checker_types.iteritems():
        enabled = "[default disabled]"
        for c_en in config.checkers:
            if c_en.name == c:
                enabled = ""
                break
        print("  %-20s %s" % (c, enabled))
    exit(1)


# A small configuration file parser:
#
class Config:
    def __init__(self, srctree, workdir, filename):
        self.path = []
        self.relpath = {}
        relpath = ""
        wd = workdir
        workdir = os.path.realpath(wd)
        #print("  ** workdir:   %s ** \n  ** canonical: %s ** \n" % (wd, workdir))

        # Look for a global config file in the scripts directory:
        file = os.path.join(srctree, "scripts/%s" % filename)
        if os.path.exists(file):
            self.path.append(file)
            self.relpath[file] = relpath

        while not args.ignore_config:
            self.file = os.path.join(workdir, filename)
            if os.path.exists(self.file):
                self.path.append(self.file)
                self.relpath[self.file] = relpath
            if len(workdir) <= len(srctree):
                break
            relpath = "%s/%s" % (basename(workdir), relpath)
            workdir = dirname(workdir)

        #print("  ** relpath: " + relpath)
        self.checkers = []
        self.cur_chk = None
        self.color = False
        self.list_only = False

        self.command = {
            "checker":   self.checker,
            "addflags":  self.addflags,
            "run":       self.runlist,
            "except":    self.exception,
            "pervasive": self.pervasive,
            "cflags":    self.cflags,
            "typedef":   self.typedef
        }

        if verbose:
            print("  ** runchecks: config path: %s" % self.path)
        for f in self.path:
            self.ParseConfig(f)

    def checker(self, argv):
        try:
            self.cur_chk = checker_types[argv[0]]
        except KeyError:
            if len(argv) < 2:
                d1 = "generic checker configurations!"
                raise CheckError("%s:%d: use 'checker %s command' for %s" %
                                 (self.file, self.lineno, argv[0], d1))

            AddChecker(Checker(argv[0], argv[1], srctree, workdir))
            self.cur_chk = checker_types[argv[0]]

    def addflags(self, argv):
        self.cur_chk.addflags(argv)

    def exception(self, argv):
        type = argv[0]
        if self.cur_chk:
            relpath = self.relpath[self.file]
            self.cur_chk.exception(type, relpath, argv[1:])
        else:
            raise CheckError("%s:%d: checker has not been set" % (self.file, self.lineno))

    def pervasive(self, argv):
        self.cur_chk.pervasive(argv)

    def runlist(self, argv):
        try:
            for c in argv:
                self.checkers.append(checker_types[c])
        except KeyError, k:
            if str(k) == "'all'":
                self.checkers = checker_types.values()
            else:
                available = "\n  -- available checkers are: %s" % ",".join(checker_types.keys())
                raise CheckError("Checker %s not found - not configured?%s" % (str(k), available))

    def cflags(self, argv):
        self.cur_chk.cflags = True

    def typedef(self, argv):
        self.cur_chk.typedef(argv)

    # Parse one configuration file in the configuration file list:
    #
    def ParseConfig(self, file):
        #print("Parsing " + file)
        f = open(file, 'r')
        self.file = file
        self.lineno = 0
        for line in f:
            self.lineno = self.lineno + 1
            token = line.split()
            if len(token) < 1:
                continue
            if token[0][0] == '#':
                continue
            try:
                self.command[token[0]](token[1:])
            except KeyError:
                if not self.cur_chk:
                    raise CheckError("%s:%s: checker has not been set" % (self.file, self.lineno))
                self.cur_chk.ParseOptional(token[0], token[1:])
            except AttributeError:
                if not self.cur_chk:
                    raise CheckError("%s:%s: checker has not been set" % (self.file, self.lineno))

        f.close()
        self.cur_chk = None

    # Option forwarding to checkers
    # and optional selection of which checkers to run:
    def ProcessOpts(self):
        self.color = args.color
        self.list_only = args.list_only

        if args.to_args:
            for opt in args.to_args[0]:
                list = opt.split(':')
                try:
                    cname = list[0]
                    checker = checker_types[cname]
                except:
                    raise CheckError("Unknown checker '%s' specified in option '%s'" % (cname, opt))
                newargs = list[1:]
                checker.cmdvec += newargs
                if verbose:
                    print("Added extra args for %s: %s" % (cname, newargs))
                continue

        if args.run_args:
            list = args.run_args[0].split(',')
            # Command line override: reset list of checkers
            self.checkers = []
            self.runlist(list)

    # We always expect at least one config file that sets up the active checkers:
    #
    def HasPathConfig(self):
        return len(self.path) > 1


# The base class for checkers:
# For specific support a particular checker, implement a subclass of this:
#
class Checker:
    def __init__(self, name, cmd, srctree, workdir, ofilter=None, efilter=None):
        self.name = name
        self.srctree = srctree
        self.workdir = workdir
        self.efilter = efilter
        if ofilter:
            self.ofilter = ofilter
        else:
            self.ofilter = self.suppress
        self.strout = ""
        self.strerr = ""
        self.cflags = False
        if cmd[0:7] == "scripts":
            cmd = os.path.join(self.srctree, cmd)
        self.cmd = cmd
        self.cmdvec = cmd.split()
        self.pervasive_opts = []  # "global" ignore list
        self.exceptions = []      # exception list for this file
        self.file_except = []     # Aggregated list of check types to ignore for this file
        self.re_except_def = {}   # check_type -> <regex to match it in stderr>
        self.doc = {}             # Used when parsing documentation: check type -> doc string
        self.cont = []
        self.last_ignore = False
        self.unclassified = 0     # With RegexFilter: Number of "red" lines not classified
        self.aux_match = None     # If set, called by RegexFilter for additional regexes

    def filter_env(self, dict):
        return dict

    def readline(self, is_stdout, fd):
        tmp_str = ""
        try:
            s = os.read(fd, 1000)
            while s != '':
                tmp_str += s
                s = os.read(fd, 1)
        except OSError:
            None

        if is_stdout:
            self.strout += tmp_str
            tmp_str = self.strout
        else:
            self.strerr += tmp_str
            tmp_str = self.strerr

        inx = tmp_str.find('\n') + 1
        if inx != 0:
            t = tmp_str[:inx]
            if is_stdout:
                self.strout = tmp_str[inx:]
            else:
                self.strerr = tmp_str[inx:]
        else:
            return ''
        return t

    def SetNonblocking(self, fd):
        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
        try:
            fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NDELAY)
        except AttributeError:
            fcntl.fcntl(fd, fcntl.F_SETFL, fl | fcntl.FNDELAY)

    def Run(self, file, verbose):
        cmdvec = self.cmdvec
        if self.cflags:
            cmdvec += c_argv
        if not args.ignore_config:
            self.file_except = set(self.exceptions + self.pervasive_opts)
        self.Postprocess()
        if not file:
            raise CheckError("error: missing file parameter")
        cmdvec.append(file)
        if args.debug:
            print("  ** running %s: %s" % (self.name, " ".join(cmdvec)))
        elif verbose:
            print("  -- checker %s --" % self.name)
        try:
            ret = self.RunCommand(cmdvec, self.ofilter, self.efilter)
        except OSError, e:
            if re.match(".*No such file or directory", str(e)):
                if len(config.checkers) == 1:
                    raise CheckError("Failed to run checker %s: %s: %s" % (self.name, self.cmd, str(e)))
                if verbose:
                    print("  ** %s does not exist - ignoring %s **" % (self.name, self.cmd))
                return 0
        ret = self.PostRun(ret)
        return ret

    def process_errline(self, eline):
        if eline != "":
            sys.stderr.write(eline)
            self.errline_cnt = self.errline_cnt + 1
        else:
            self.errline_suppressed = self.errline_suppressed + 1

    def RunCommand(self, cmdvec, ofilter, efilter):
        my_env = self.filter_env(os.environ)
        child = subprocess.Popen(
            cmdvec, shell=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            cwd=".", env=my_env)
        sout = child.stdout
        serr = child.stderr
        ofd = sout.fileno()
        efd = serr.fileno()
        oeof = False
        eeof = False
        self.errline_suppressed = 0
        self.errline_cnt = 0
        check_errors = []
        self.SetNonblocking(ofd)
        self.SetNonblocking(efd)
        while True:
            ready = select.select([ofd, efd], [], [], 0.1)
            if ofd in ready[0]:
                if child.poll() is not None:
                    oeof = True
                oline = self.readline(True, ofd)
                while oline != '':
                    if ofilter is not None:
                        check_err = ofilter(oline, verbose)
                        if check_err is not None:
                            self.process_errline(check_err)
                    else:
                        sys.stdout.write(oline)
                    oline = self.readline(True, ofd)
            if efd in ready[0]:
                if child.poll() is not None:
                    eeof = True
                eline = self.readline(False, efd)
                while eline != '':
                    if efilter:
                        check_err = efilter(eline, verbose)
                        if check_err is not None:
                            self.process_errline(check_err)
                    else:
                        sys.stderr.write(eline)
                    eline = self.readline(False, efd)
            if oeof and eeof:
                break
        serr.close()
        sout.close()
        retcode = child.wait()
        if self.errline_cnt:
            if not retcode:
                retcode = 131
        else:
            retcode = 0
        if self.errline_suppressed:
            if verbose:
                print("%s  ** %d suppressed errors/warnings from %s%s" %
                      (BLUE, len(check_errors), self.name, ENDCOLOR))
        return retcode

    def ParseOptional(self, cmd, argv):
        raise CheckError("Undefined command '%s' for checker '%s'" % (cmd, self.name))

    # Called as final step before running the checker:
    def Postprocess(self):
        # Do nothing - just for redefinition in subclasses
        return

    # Called as a post processing step after running the checker:
    # Input parameter is return value from Run()
    def PostRun(self, retval):
        # Do nothing - just for redefinition in subclasses
        return retval

    # Default standard output filter:
    def suppress(self, line, verbose):
        if verbose:
            sys.stdout.write(line)

        return

    # A matching filter for stderr:
    def RegexFilter(self, line, verbose):
        if self.cont:
            m = re.match(self.cont[0], line)
            self.cont = self.cont[1:]
            if m:
                if self.last_ignore:
                    return ""
                else:
                    return line

        for t, regex in self.re_except_def.iteritems():
            r = "^(.*:\d+:)\s(\w+:)\s(%s.*)$" % regex[0]
            m = re.match(r, line)
            if not m and self.aux_match:
                m = self.aux_match(line, regex[0])
            if m:
                if len(regex) > 1:
                    self.cont = regex[1:]
                if t in self.file_except:
                    self.last_ignore = True
                    return ""
                else:
                    warn = m.group(2)
                    if not m.group(2):
                        warn = "WARNING:"
                    self.last_ignore = False
                    return "%s%s %s:%s%s%s: %s %s\n" % (BROWN, m.group(1), self.name.upper(),
                                                        BLUE, t, ENDCOLOR, warn, m.group(3))
        self.unclassified = self.unclassified + 1
        return BLUE + self.name + ":" + RED + line + ENDCOLOR

    def ListTypes(self):
        if len(self.re_except_def) > 0:
            print(BLUE + BOLD + "  Check types declared for %s in runchecks configuration%s" %
                  (self.name, ENDCOLOR))
        for t, regex in self.re_except_def.iteritems():
            print("\t%-22s %s" % (t, "\\n".join(regex)))
        if len(self.re_except_def) > 0:
            print("")
        return 0

    def addflags(self, argv):
        self.cmdvec += argv

    def exception(self, type, relpath, argv):
        for f in argv:
            if f == ("%s%s" % (relpath, bfile)):
                #print("  ** Appending %s (%s, %s)" % (type,relpath,bfile))
                self.exceptions.append(type)

    def pervasive(self, argv):
        self.pervasive_opts += argv

    def typedef(self, argv):
        exp = " ".join(argv[1:])
        elist = exp.split("\\n")
        self.re_except_def[argv[0]] = elist


# Individual checker implementations:
#

# checkpatch
class CheckpatchRunner(Checker):
    def __init__(self, srctree, workdir):
        Checker.__init__(self, "checkpatch", "scripts/checkpatch.pl", srctree, workdir)
        self.cmdvec.append("--file")
        self.line_len = 0
        # checkpatch sends all it's warning and error output to stdout,
        # redirect and do limited filtering:
        self.ofilter = self.out_filter

    def ParseOptional(self, cmd, argv):
        if cmd == "line_len":
            self.line_len = int(argv[0])
        else:
            Checker.ParseOptional(self, cmd, argv)

    def Postprocess(self):
        if config.color:
            self.cmdvec.append("--color=always")
        if self.line_len:
            self.cmdvec.append("--max-line-length=%d" % self.line_len)
        if self.file_except:
            self.cmdvec.append("--ignore=%s" % ",".join(self.file_except))

    # Extracting a condensed doc of types to filter on:
    def man_filter(self, line, verbose):
        t = line.split()
        if len(t) > 1 and t[1] != "Message":
            sys.stdout.write("\t%s\n" % t[1])

    def out_filter(self, line, verbose):
        # --terse produces this message even with no errors,
        #  suppress unless run with -v:
        if not verbose and re.match("^total: 0 errors, 0 warnings, 0 checks,", line):
            return None
        return line

    def ListTypes(self):
        print(BLUE + BOLD + "  Supported check types for checkpatch" + ENDCOLOR)
        # Parse help output:
        cmdvec = ["%s/scripts/checkpatch.pl" % self.srctree, "--list-types"]
        self.RunCommand(cmdvec, self.man_filter, None)
        print("")
        return 0


# sparse
class SparseRunner(Checker):
    def __init__(self, srctree, workdir):
        Checker.__init__(self, "sparse", "sparse", srctree, workdir)
        self.efilter = self.RegexFilter

    def sparse_name(self, rs_type):
        l_name = rs_type.lower()
        s_name = ""
        for c in l_name:
            if c == '_':
                s_name += '-'
            else:
                s_name += c
        return s_name

    def runchecks_name(self, sparse_type):
        u_name = sparse_type.upper()
        rc_name = ""
        for c in u_name:
            if c == '-':
                rc_name += '_'
            else:
                rc_name += c
        return rc_name

    def Postprocess(self):
        if self.file_except:
            for e in self.file_except:
                self.cmdvec.append("-Wno-%s" % self.sparse_name(e))

    # Extracting a condensed doc of types to filter on:
    def man_filter(self, line, verbose):
        if self.doc_next:
            doc = line.strip()
            self.doc[self.doc_next] = doc
            self.doc_next = False
            return
        match = re.search("^\s+-W([\w-]+)\s*$", line)
        if match:
            name = match.group(1)
            if re.match("sparse-", name):
                return
            rs_type = self.runchecks_name(name)
            self.doc_next = rs_type

    def ListTypes(self):
        # Parse manual output:
        cmdvec = ["man", "sparse"]
        self.doc_next = False
        ret = self.RunCommand(cmdvec, self.man_filter, None)
        if ret:
            return ret
        print(BLUE + BOLD + "\n  Types derived from sparse from documentation in manpage" + ENDCOLOR)
        for t, doc in self.doc.iteritems():
            print("\t%-22s %s" % (t, doc))
            try:
                regex = self.re_except_def[t]
                print("\t%-22s %s" % ("", GREEN + "\\n".join(regex) + ENDCOLOR))
            except:
                print("\t%-22s %s" % ("", BLUE + self.name + ":" + RED +
                                      "(regex match (typedef) missing)" + ENDCOLOR))
        print(BLUE + BOLD +
              "\n  Types for sparse only declared for runchecks or not documented in manpage" +
              ENDCOLOR)
        for t, regex in self.re_except_def.iteritems():
            try:
                self.doc[t]
            except:
                print("\t%-22s %s" % (t, GREEN + "\\n".join(regex) + ENDCOLOR))
        print("")
        return 0


# smatch
class SmatchRunner(Checker):
    def __init__(self, srctree, workdir):
        Checker.__init__(self, "smatch", "smatch", srctree, workdir)
        self.efilter = self.RegexFilter
        self.ofilter = self.out_filter
        self.aux_match = self.warn_matcher

    def out_filter(self, line, verbose):
        # Some of the error and warning output goes to standard output
        return self.RegexFilter(line, verbose)

    # Smatch uses both the standard formatting of messages and a slightly
    # different one - capture the alternate one here:
    def warn_matcher(self, line, regex):
        r = "^(.*:\d+)\s[\w\d\(\)]+\(\)\s(\w+:)?\s?(%s.*)$" % regex
        return re.match(r, line)


# checkdoc
class CheckdocRunner(Checker):
    def __init__(self, srctree, workdir):
        Checker.__init__(self, "checkdoc", "scripts/kernel-doc", srctree, workdir)
        self.cmdvec.append("-none")
        self.efilter = self.RegexFilter


# coccicheck (coccinelle) (WIP)
class CoccicheckRunner(Checker):
    def __init__(self, srctree, workdir):
        Checker.__init__(self, "coccicheck", "scripts/coccicheck", srctree, workdir)
        self.debug_file = None
        self.efilter = self.CoccicheckFilter

    def filter_env(self, dict):
        newdict = os.environ
        # If debug file is not set by the user, override it and present the output on stderr:
        if "DEBUG_FILE" not in newdict:
            self.debug_file = '/tmp/cocci_%s.log' % os.getpid()
            newdict["DEBUG_FILE"] = self.debug_file
        return newdict

    def CoccicheckFilter(self, line, verbose):
        self.unclassified = self.unclassified + 1
        if re.match(".*spatch -D report", line):
            if verbose:
                sys.stdout.write(line)
        else:
            return BLUE + self.name + ":" + RED + line + ENDCOLOR

    def PostRun(self, retval):
        if not self.debug_file:
            return retval
        f = open(self.debug_file)
        for line in f:
            line = self.CoccicheckFilter(line, verbose)
            if line:
                sys.stderr.write(line)
        f.close()
        if self.debug_file:
            os.remove(self.debug_file)
        if retval == 0:
            retval = ret
        return retval


checker_types = {}


def AddChecker(checker):
    checker_types[checker.name] = checker


#
# Start main program:
#
program = os.path.realpath(sys.argv[0])
progname = basename(program)
scriptsdir = dirname(program)
srctree = dirname(scriptsdir)
argv = []
c_argv = []
workdir = os.getcwd()

AddChecker(CheckpatchRunner(srctree, workdir))
AddChecker(SparseRunner(srctree, workdir))
AddChecker(SmatchRunner(srctree, workdir))
AddChecker(CheckdocRunner(srctree, workdir))
AddChecker(CoccicheckRunner(srctree, workdir))

argparser = argparse.ArgumentParser(
    prog='runchecks',
    description='Run code checkers in a conformant way.')

# Prepare arguments the way argparse likes them:
#
argc = 1
for arg in sys.argv[1:]:
    argc = argc + 1
    arg = arg.replace("--run:", "--run=")
    arg = arg.replace("--to-", "--to=")
    if arg == "--":
        c_argv = sys.argv[argc:]
        break
    argv.append(arg)


argparser.add_argument('c_file', help='File to run checkers on', nargs="*")
argparser.add_argument('--list', dest='list_only', action='store_true',
                       help='List the different configured checkers and the list of interpreted check'
                       'types for each of them.')
argparser.add_argument('--color', action='store_true',
                       help='Use coloring in the error and warning output. In this mode '
                       'output from checkers that are supported by typedefs but not '
                       'captured by any such will be highlighted in red to make it '
                       'easy to detect that a typedef rule is missing. See -t below.')
argparser.add_argument('-f', dest='force', action='store_true',
                       help='Force mode: force runchecks to run a full run in directories/trees'
                       'where runchecks does not find a runchecks.cfg file. The default '
                       'behaviour is to skip running checkers in directories/trees '
                       'where no matching runchecks.cfg file is found either in the '
                       'source file directory or above.')
argparser.add_argument('-n', dest='ignore_config', action='store_true',
                       help='Ignore all runchecks.cfg files except the one in scripts, '
                       'which are used for basic runchecks configuration. This allows '
                       'an easy way to run a "bare" version of checking where all '
                       'issues are reported, even those intended to be suppressed.'
                       'Implicitly enables force mode.')
argparser.add_argument('-w', dest='no_error', action='store_true',
                       help='Behave as if 0 on exit from all checkers. Normally '
                       'runchecks will fail on the first checker to produce errors or '
                       'warnings, in fact anything that produces not suppressed '
                       'output on stderr. This is to make it easy to work interactively, '
                       'avoiding overlooking anything, but sometimes it is useful to '
                       'be able to produce a full report of status.')
argparser.add_argument('-t', dest='error_on_red', action='store_true',
                       help='Typedef setup mode: For checkers where runchecks enable typedefs: '
                       'Behaves as -w except for stderr output that is not captured '
                       'by any typedefs. This is a convenience mode while '
                       'fixing/improving typedef setup. Use with --color to get red '
                       'output for the statements to capture with new typedefs.')
argparser.add_argument('-v', dest='verbose', action='store_true',
                       help='Verbose output. Also enabled if called from make with V=1,'
                       'but it is useful to be able to only enable verbose mode for runchecks.')
argparser.add_argument('-d', dest='debug', action='store_true',
                       help='Debugging output - more verbose.')
argparser.add_argument('--run', dest='run_args', nargs=1, metavar='<checker1>[,checker2...]',
                       help='Override the default set of checkers to be run for each source file. '
                       'By default the checkers to run will be the intersection of the checkers '
                       'configured by "run" commands in the configuration file and the'
                       'checkers that is actually available on the machine. Use "all"'
                       'to run all the configured checkers.')
argparser.add_argument('--to', dest='to_args', action='append', nargs=1,
                       metavar='<checker>:<option1>[,>option2>...]',
                       help='Send extra options to a specific checker. '
                       'Multiple --to options are allowed.')

args = argparser.parse_args(argv)

verbose = args.verbose
no_error = args.no_error or args.error_on_red
force = args.force or args.ignore_config

if not args.verbose:
    try:
        verb = int(os.environ["V"])
        if verb != 0:
            verbose = True
    except KeyError:
        verbose = False

if not os.path.exists(os.path.join(srctree, "MAINTAINERS")):
    srctree = None

try:
    file = args.c_file[0]
    bfile = basename(file)
    workdir = dirname(file)
except:
    bfile = None
    file = None
    if not args.list_only:
        argparser.print_help()

unclassified = 0

if args.debug:
    print("Kernel root:\t%s\nFile:\t\t%s\nWorkdir:\t%s" %
          (srctree, bfile, workdir))
    print("C args:\t\t%s\nargv:\t\t%s\n" % (" ".join(c_argv), " ".join(argv)))

try:
    config = Config(srctree, workdir, "runchecks.cfg")
    config.ProcessOpts()

    if not config.HasPathConfig() and not config.list_only and not force:
        if args.verbose:
            print("  ** %s: No configuration found - skip checks for %s" % (progname, file))
        exit(0)

    if config.color:
        GREEN = '\033[32m'
        RED = '\033[91m'
        BROWN = '\033[33m'
        BLUE = '\033[34m'
        BOLD = '\033[1m'
        ENDCOLOR = '\033[0m'
    else:
        BOLD = ''
        GREEN = ''
        RED = ''
        BROWN = ''
        BLUE = ''
        ENDCOLOR = ''

    ret = 0
    for checker in config.checkers:
        if config.list_only:
            ret = checker.ListTypes()
        else:
            ret = checker.Run(file, verbose)
            unclassified += checker.unclassified
        if ret and not no_error:
            break

    if no_error and not (args.error_on_red and unclassified > 0):
        ret = 0
except CheckError, e:
    print("  ** %s: %s" % (progname, str(e)))
    ret = 22
except KeyboardInterrupt:
    if verbose:
        print("  ** %s: Interrupted by user" % progname)
    ret = 4

exit(ret)
